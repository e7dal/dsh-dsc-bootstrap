data {
  kafka {
    topic {
      input {
        average-handling-time = ${?KAFKA_AVERAGE_HANDLING_TIME_TOPIC}
        queuers-and-callers = ${?KAFKA_QUEUERS_AND_CALLERS_TOPIC}
        queuers-per-service = ${?KAFKA_QUEUERS_PER_SERVICE_TOPIC}
        wait-time = ${?KAFKA_WAIT_TIME_TOPIC}
      }

      output {
        predicted-amt-callers-15m = ${?KAFKA_PRED_CALLERS_TOPIC}
        predicted-amt-queuers-15m = ${?KAFKA_PRED_QUEUERS_TOPIC}
        predicted-wait-15m = ${?KAFKA_PRED_WAIT_15M_TOPIC}
        predicted-wait-5m = ${?KAFKA_PRED_WAIT_5M_TOPIC}
      }
    }
  }

  microbatch.interval = 3
}


kafka {
  producer {
    bootstrap.servers = ${?KAFKA_BOOTSTRAP_SERVERS}
    security.protocol = ${?KAFKA_SECURITY_PROTOCOL}
    ssl.truststore.location = ${?KAFKA_SSL_TRUSTSTORE_LOCATION}
    ssl.truststore.password = ${?KAFKA_SSL_TRUSTSTORE_PASSWORD}
    ssl.keystore.location = ${?KAFKA_SSL_KEYSTORE_LOCATION}
    ssl.keystore.password = ${?KAFKA_SSL_KEYSTORE_PASSWORD}
    ssl.key.password = ${?KAFKA_SSL_KEY_PASSWORD}
  }

  consumer {
    bootstrap.servers = ${?KAFKA_BOOTSTRAP_SERVERS}
    group.id = "model-scoring-processor"
    security.protocol = ${?KAFKA_SECURITY_PROTOCOL}
    ssl.truststore.location = ${?KAFKA_SSL_TRUSTSTORE_LOCATION}
    ssl.truststore.password = ${?KAFKA_SSL_TRUSTSTORE_PASSWORD}
    ssl.keystore.location = ${?KAFKA_SSL_KEYSTORE_LOCATION}
    ssl.keystore.password = ${?KAFKA_SSL_KEYSTORE_PASSWORD}
    ssl.key.password = ${?KAFKA_SSL_KEY_PASSWORD}
  }
}